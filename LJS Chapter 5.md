================= 5.1 "Методы примитивов"

"Методы у примитивов"

Функции тоже являются объектами

У примитивов тоже есть методы и при этом сохраняют "лёгкость"

Как пример строчных: метод ".toUpperCase()"
Как пример числовых: метод ".toFixed(n)"

Объекты в "if" всегда дают "true"

null и undefined являются исключениями
У них нет объектов-обёрток (речь о "String()", "Number()", "Boolean()")

Примитивы не могут хранить дополнительные данные, только объекты на такое способны

================= 5.2 "Числа"

"Число "е""

В JavaScript можно использовать букву "e", чтобы укоротить запись числа
Она добавляется к числу и заменяет указанное количество нулей:
"1e6" // 1 миллион, 1 и 6 нулей

Записать микросекунду в укороченном виде можно также используя "e":
"1е-6" // 6 нулей теперь слева

Метод "num.toString(base)" возвращает строковое представление числа num в системе счисления base

Округление

	-Math.floor - Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2
	-Math.ceil - Округление в большую сторону: 3.1 становится 4, а -1.1 — -1
	-Math.round - Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1
	-Math.trunc - Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1

Метод ".toFixed(n)" - округляет число до "n" знаков после запятой
("n" - желаемое кол-во знаков после запятой)
Результатом ".toFixed" является строка

Если число слишком большое, то оно вернёт "Infinity"

"isNaN(value)" - преобразует значение в число и проверяет является ли оно NaN

"isFinite(value)" - преобразует аргумент в число и возвращает true, если оно является обычным числом
(т.е. не "NaN", "Infinity", "-Infinity"
(т.е. "isFinite("15")" - будет "true")

Object.is, который сравнивает значения примерно как ===, но более надёжен:
"Object.is(NaN, NaN) === true"

Для явного преобразования к числу можно использовать "+" или "Number()"

"parseInt" и "parseFloat"

Они "читают" число из строки
Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число
Функция "parseInt" возвращает целое число, а "parseFloat" возвращает число с плавающей точкой
(т.е. если мы в "parseInt" запишем "12.3", то он просто вернёт "12")

Функции "parseInt"/"parseFloat" вернут "NaN", если не смогли прочитать ни одну цифру
(например: "parseInt('a123')", вернёт "NaN")

"Math"

В JavaScript встроен объект "Math", который содержит различные математические функции и константы
Примеры:
	-Math.random() - Возвращает случайное число в диапазоне от 0 до 1
	-Math.max(a, b, c...)/Math.min(a, b, c...) - Возвращает наибольшее/наименьшее число из перечисленных аргументов
	-Math.pow(n, power) - Возвращает число n, возведённое в степень power

================= 5.3 "Строки"

В JavaScript любые текстовые данные являются строками. Не существует отдельного типа "символ"

Символ "\n" - переносит текст на новую строку
Символ "\" - используется, чтобы в тексте поставить кавычку (пример: "'I\'m the Walrus!'")
(но с обратными кавычками так: "`I'm the Walrus!`")

"[]" - позволяет получить позицию элемента, при не находе позиции возвращает "undefined"
"charAt" - делает то же самое, что и "[]", но при не находе позиции, возвращает пустую строку

Методы ".toLowerCase()" и ".toUpperCase()" меняют регистр символов

".str.indexOf('id')" - ищет первое совпадение в строке и возвращает индекс ближайшего совпадения
(вторым аргументом можно задать индекс, с какой позиции метод начнёт поиск)

метод ".includes('s')" - ищет наличие 's', и если присутствует - возвращает "true", если нет - "false"
(можно задать второй аргумент, и тогда метод будет искать с определённой позиции)

".codePointAt(pos)" - возвращает код для символа, находящийся на "pos"
"String.fromCodePoint(code)" - Создаёт символ по его коду "code"

"str.localeCompare(str2)" - возвращает число, которое показывает, какая строка больше:
	-Отрицательное число, если str меньше str2
	-Положительное число, если str больше str2
	-"0", если строки равны

================= 5.4 "Массивы"

Два варианта синтаксиса создания пустого массива:
	"let arr = new Array()"
	"let arr =[]"

Элементы массива нумеруются, начиная с нуля
Можно получить элемент, указав его индекс в "[]"
Пример:

```js
let arr = ['John', 'Milena']
alert (arr[0]) // 'John'
```

По индексу можно заменить элемент:
```js
let arr = ['John', 'Milena']
arr[1] = 'Andrew'
alert(arr[1]) // 'Andrew'
```

Или добавить новый:
```js
let arr = ['John', 'Milena']
arr[2] = 'Nick'
alert(arr) // ['John', 'Milena', 'Nick']
```

В массиве могут храниться элементы любого типа (даже объекты)

Массив - это подвид объектов

Мы действительно можем присвоить массиву любые свойства, но так делать не надо :)

Для перебора массива лучше использовать не просто "for", а именно "for...of"
(выглядит более читаемо)
А вот "for...in" лучше не использовать
(т.к. "for...in" не оптимизирован под массивы)

Значение "length" можно перезаписать, но этот процесс необратим:

"let arr = [1, 2, 3, 4, 5]

arr.length = 2
alert(arr) // [1, 2]

arr.length = 5
alert(arr[3]) // undefined"

(можно очистить массив путём "arr.length = 0")

Массивы также могут содержать массивы

================= 5.5 "Методы массивов"

Такие методы, как "push" и "shift", добавляют/удаляют элементы, сдвигая очередь

Вызов "fruits.push(...)" равнозначен "fruits[fruits.length]"

Методы "push" и "unshift" могут добавлять сразу несколько элементов

"Список и описание методов массивов"

pop - выдавливает последний элемент
push - пушит в конец массива элемент
unshift - добавляет в начало массива элемент
shift - извлекает из начала массива элемент

slice - создаёт новый массив, копируя элементы с (start и end), не включая end
splice - (position, deleteCount, и вставляет items)
concat - копирует элементы текущего массива и добавляет в него (items) (если что-то из items является массивом, то берёт его элементы), возвращает новый массив

sort - сортирует массив по функции на месте, и возвращает его, меняя исходный
filter - коллбек функция с условием (возвращает массив)

reduce - задает 2 параметра и суммирует их, 1ый - аккумулирующий, 2ой - индекс
map - производит работу с каждым элементом (создаёт новый массив)
forEach - вызывает функцию для каждого элемента, но не возвращает новый массив
reverse - разворачивает массив

split - разбивает строку в массив
join - создает строку из элементов массива

================= 5.6 

"Symbol.iterator"

Позволяет перебирать объект
Его синтаксис: "[Symbol.iterator]() { ... }"
Также в нём обязательно должен присутствовать метод "next()"
И в "next" след. синтаксис: "{done: Boolean, value: any}", где "done: true" означает, что итерация закончена

Пример:

```js
let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  alert(num); // 1, затем 2, 3, 4, 5
}
```

Цикл "for...of" также можно использовать и для перебора строки (текста)

Итерируемые объекты – это объекты, которые реализуют метод "Symbol.iterator"

Псевдомассивы – это объекты, у которых есть индексы и свойство "length", то есть, они выглядят как массивы

Итерируемый объект может не быть псевдомассивом. И наоборот: псевдомассив может не быть итерируемым
(разница между ними в том, что псевдомассив имеет индексы, соответственно и свойство "length")

"Array.from"

Метод "Array.from" принимает итерируемый объект или псевдомассив и делает из него массив
(После чего мы можем использовать на нём методы массивов)

2-ым аргументом можно задать функцию, которая будет применена к каждому элементу перед добавлением
Пример:

```js
let arr = Array.from(range, num => num * num)
```

================= 5.7 "Map и Set"

"Map" - обращается к элементам массива
"Set" - тоже самое, что и "Map", но на выходе даёт уникальные значения, не даёт дублировать

"new Map()" - создание коллекции

	-"map.set(key, value)" - записывает по ключу "key" значение "value"
	-"map.get(key)" - возвращает значение по ключу или "undefined", если ключ "key" отсутствует
	-"map.has(key)" - возвращает "true", если ключ "key" присутствует в коллекции, иначе "false"
	-"map.delete(key)" - удаляет элемент по ключу "key"
	-"map.clear()" - очищает коллекцию от всех элементов
	-"map.size" - возвращает текущее количество элементов

"new Set()" - создаёт Set

	-"set.add(value)" - добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект "set"
	-"set.delete(value)" - удаляет значение, возвращает "true"
	-"set.has(value)" - возвращает "true", если значение присутствует
	-"set.clear()" – удаляет все имеющиеся значения
	-"set.size" - возвращает количество элементов

================= 5.8 "WeakMap и WeakSet"

"WeakMap" - ключами могут быть только объекты, и является более "слабым", из него можно вытащить данные, что позволяет оптимизировать работу
"WeakSet" - значениями могут быть только объекты, и если какой-то объект удаляется, он не хранится как мусор, а удаляется с концами

В "WeakMap" присутствуют следующие методы:

	-"weakMap.get(key)"
	-"weakMap.set(key, value)"
	-"weakMap.delete(key)"
	-"weakMap.has(key)"

В "WeakSet" присутствуют следующие методы:

	-"set.add(value)"
	-"set.has(value)"
	-"set.delete(value)"

================= 5.9 "Object.keys, values, entries"

Для простых объектов доступны следующие методы:

"Object.keys(obj)" - возвращает массив ключей
"Object.values(obj)" - возвращает массив значений
"Object.entries(obj)" - возвращает массив пар [ключ, значение]

================= 5.10 "Деструктурирующее присваивание"

Пример деструктуризации массива:

```js
let arr = ["Ilya", "Ivanov"]

let [firstName, surname] = arr
alert(firstName) // "Ilya"
alert(surname) // "Ivanov"
```

То есть мы привязывем индексы к переменным
И теперь мы можем использовать переменные вместо элементов массива

То есть вот это:
```js
let [firstName, surname] = arr
```

И вот это:
```js
let firstName = arr[0]
let surname = arr[1]
```

2 примера выше идентичны

При первой записи, лишние элементы могут быть пропущены, используя ","
Пример:
```js
let [firstName, , title] = arr
```
(Мы записали элементы индекса "0" и "2")
(Если элементов 3, а мы задали только для 2-ух, то последующие будут пропущены)

Такая запись - валидна:
```js
let [one, two, three] = new Set([1, 2, 3])
```

Это работает с любым перебираемым объектом с правой стороны

Для левой стороны тоже валидна и такая запись:

```js
let user = {}
[user.name, user.surname] = "Ilya Ivanov".split(' ')

alert(user.name) // Ilya
```

"Остаточные параметры"

Чтобы захватить, например, из 5 элементов - первые 2 и все остальные, то можно использовать следующий синтаксис:

```js
let [name1, name2, ...rest] = ["Julius", "Caesar", "Look", "in the mirror"]

alert(name1) // "Julius"
alert(name2) // "Caesar"

alert(rest[0]); // "Look"
alert(rest[1]); // "in the mirror"
alert(rest.length); // 2
```

Т.е. синтаксис "rest", это - "...rest"

"Значения по умолчанию"

Если в массиве меньше значений, чем в присваивании, то ошибки не будет, мы просто получим "undefined" при вызове переменных

Мы можем задать значение по умолчанию следующим синтаксисом:
```js
"let [name = "Guest", surname = "Anonymous"] = ["Julius"]

alert(name) // "Julius"
alert(surname) // "Anonymous"
```

Значения по умолчанию выполняются, только если значения отсутствуют

"Деструктуризация объектов"

Объекты тоже можно деструктурировать
Например:

```js
let a = { width: 50, height: 100 }

let { height, width } = a

alert(height) // 50
alert(width) // 100"

Также можно присвоить и таким путём:

"let a = { width: 50, height: 100 }

let { height: h, width: w } = a

alert(h) // 50
alert(w) // 100
```

Двоеточие показывает "что: куда идёт"

Для отсутствующих свойств мы можем установить значение по умолчанию используя "=":

```js
let a = { width: 50 }

let { weight = 25, height = 100, width } = a

alert(width) // 50
alert(height) // 100
alert(weight) // 25"

":" и "=" можно совмещать
Выглядит это так:

"let { width: w = 50, height: h = 100 }

alert(w) // 50
alert(h) // 100
```

Можем ли мы взять необходимые нам, а остальные присвоить куда-нибудь?
Конечно, и можно реализовать это при помощи "...rest":

```js
let a = { width: 50, height: 100, weight: 25 }

let { width, ...rest } = a

alert(rest.height) // 100
alert(rest.weight) // 25
```

Если мы хотим взять объект и использовать все свойства по умолчанию, то обязательно записать так:

```js
showMe({}) // всё по умолчанию

showMe() // ошибка
```

================= 5.11 "Дата и время"

"Date"

Синтаксис: "new Date"
```js
let now = new Date()
alert( now ) // покажет текущие дату и время
```

Если аргумент всего один, и это строка, то из неё "прочитывается" дата:
```js
let date = new Date("2017-01-26")
alert(date)
```

(Если поставить в аргумент число, то это будет "прочитано" как миллисекунды:

"let Jan01_1970 = new Date(0)
alert(Jan01_1970)")

Запись "new Date"

"new Date(year, month, date, hours, minutes, seconds, ms)"
У объекта "Date" (который выше) - только первые 2 аргумента обязательны

	-"year" должен состоять из четырёх цифр: значение 2013 корректно, 98 – нет
	-"month" начинается с 0 (январь) по 11 (декабрь)
	-Параметр "date" здесь представляет собой день месяца. Если параметр не задан, то принимается значение "1"
	-Если параметры hours/minutes/seconds/ms отсутствуют, их значением становится "0"

Примеры:
	"new Date(2011, 0, 1, 0, 0, 0, 0); // "1 Jan 2011, 00:00:00""
	"new Date(2011, 0, 1) // тоже самое"

"Получение компонентов даты"

"getFullYear()" - получить год (в 4 цифры)
"getMonth()" - месяц от "0" до "11"
"getDate()" - день месяца от "1" до "31"
("getHours()", "getMinutes()", "getSeconds()", "getMilliseconds()" - по той же аналогии)
"getDay()" - вернуть день недели от "0" (воскресенье) до "6" (суббота)

(Методы возвращают значения в соответствии с местным часовым поясом)

(Если вы хотите поставить "UTC+0", то для всех методов запись меняется на:
"getUTCFullYear()", "getUTCMonth()")

"getTimezoneOffset()" - возвращает разницу UTC в минутах

"Установка компонентов даты"

Такие же методы, но только вместо "get", у нас - "set"

Пример: "setFullYear(year, month, date)", "setDate(date)"
Также поддерживается UTC вариант ("setUTCHours()")

Если мы вводим ошибочные данные в дату, то объект "Date" автоматически их исправит
Например: "Date (2021, 0, 32)"
Выведет 1-ое февраля

Метод "Date.now()" возвращает текущее время

"Date.parse(str)" считывает дату из строки


================= 5.12 "JSON"

"JSON.stringify(**переменная**)" - для преобразования объекта в строку
"JSON.parse(**переменная**)" - для преобразования JSON в объект

"JSON.stringify"

"JSON.stringify" может быть применен к примитивам (также и к булево, и к "null")

Игнорирует методы, символы (Symbol) и "undefined"

"JSON.stringify" = "toJSON"

"JSON.parse"

Преобразует строку в значения (например строковые числа переведёт в числовые)

=================

[[LJS]]