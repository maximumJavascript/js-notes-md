================= 6.1 "Рекурсия"

Рекурсия нужна в ситуациях, когда задача может быть разделена на несколько аналогичных, но более простых задач

Любая рекурсия может быть переделана в цикл
И обычно вариант с циклом будет эффективнее и менее затратным
(Но код с рекурсией более короткий и понятный, поэтому, не всегда цикл более оптимальный)

Добавление от себя:

Рекурсия - это функция, которая вызывает сама себя

================= 6.2

Вызвать функцию можно с любым количеством аргументов
Если в функции всего 2 аргумента, то посчитаются только 2 первых аргумента
(Ошибки не будет)

Или функция, принимающая любое кол-во аргументов будет иметь такой синтаксис:

```js
function sumAll (...args) {
  let sum = 0

  for (let arg of args) sum += arg

  return sum
}
```
(Функция выше суммирует все аргументы и выводит итог)

"...rest" всегда должен быть последним

================= 6.3 "Замыкание"

У глобального окружения нет внешнего окружения, так что оно указывает на "null"

Функция называется "вложенной", когда она создаётся внутри другой функции

Все функции являются замыканиями
Замыкание - это наличие лексического окружения

================= 6.4 "var"

У "var" не существует блочной области видимости

Пример:
```js
if (true) {
  var test = true
}

alert(test) // true
```
Т.е. переменная существует вне блока "if"
"var" игнорирует блоки
"var" не может быть локальной

Если блок кода находится внутри функции, то "var" становится локальной переменной

Если в блоке кода дважды объявить одну и ту же переменную "let", будет ошибка:
```js
let user
let user // SyntaxError
```

Используя "var", можно переобъявлять переменную сколько угодно раз. Повторные "var" игнорируются:
```js
var name = "John"
var name
var name = "Carl"

alert(name) // Carl
```

Хойстинг "var" находится в самом верху

Как это работает:
```js
function sayHi() {
  var phrase; // объявление переменной срабатывает вначале...

  alert(phrase); // undefined

  phrase = "Привет"; // ...присвоение - в момент, когда исполнится данная строка кода.
}

sayHi();
```
Т.е. переменные существуют, но присваиваются они позже, а до этого момента имеют значение "undefined"

================= 6.5 "Глобальные объекты"

Глобальный объект предоставляет переменные и функции, доступные в любом месте кода

В браузере он называется "window", в Node.js - "global", в другой среде исполнения может называться иначе

Если скрипт может выполняться и в другом окружении, лучше будет "globalThis"

================= 6.6 "NFE"

NFE:
```js
let sayHi = function func(who) {
  alert(`Hello, ${who}`)
}

sayHi("John") // "Hello, John"
```
Это Function Expression, которой дали имя

Есть две важные особенности имени func, ради которого оно даётся:

	-Оно позволяет функции ссылаться на себя же
	-Оно не доступно за пределами функции

================= 6.7 "Синтаксис "new Function""

Главное отличие от других способов объявления функции, которые были рассмотрены ранее заключается в том, что функция создаётся полностью "на лету" из строки:
```js
let sayHi = new Function('alert("Hello")')

sayHi() // Hello
```
"new Function" имеет доступ только к глобальным переменным

================= 6.8 "setTimeout, setInterval"

"Планирование вызова":

	-"setTimeout" позволяет вызвать функцию **один раз** через определённый интервал времени
	-"setInterval" позволяет вызывать функцию регулярно, повторяя вызов через

"setTimeout"

Синтаксис:
```js
let timerId = setTimeout(func|code, [delay], [argN], [argN], ...)
```

Например, вызов "sayHi" спустя одну секунду:
```js
function sayHi() {
  alert('Привет')
}

setTimeout(sayHi, 1000)
```

С аргументами:
```js
function sayHi(phrase, who) {
  alert( phrase + ', ' + who )
}

setTimeout(sayHi, 1000, "Привет", "Карл") // Привет, Карл
```

Подметим, что так делать ошибочно:
```js
// не правильно!
setTimeout(sayHi(), 1000)
```
Речь естественно о скобках после "sayHi", т.к. в таком случае функция ничего не возвращает и мы получаем "undefined"

"clearTimeout" отменяет вызов "setTimeout" и ничего не происходит:
```js
let timerId = setTimeout(...)
clearTimeout(timerId)
```

"setInterval"

"setInterval" имеет точно такой же синтаксис, что и "setTimeout"

"setInterval" работает абсолютно также, и имеет такие же аргументы, единственное отличие - функция запускается не один раз, а периодически через указанный интервал времени

Для остановки дальнейшего выполнения функции необходимо вызвать:
"clearInterval(timerId)"

Следующий пример выводит сообщение каждые 2 секунды, но через 5 секунд вывод прекращается:

```js
// повторить с интервалом 2 секунды
let timerId = setInterval(() => alert('tick'), 2000)

// остановить вывод через 5 секунд
setTimeout(() => { clearInterval(timerId) alert('stop') }, 5000)
```

Рекурсивный "setTimeout" позволяет задать задержку между выполнениями более точно, чем "setInterval"
"setTimeout" с рекурсией более гибок, чем "setInterval"

Для "setInterval" функция остаётся в памяти до тех пор, пока не будет вызван "clearInterval"

Нулевой "delay" будет выполнен только после того, как будет загружен весь код, а потом уже, сразу же вызовет "delay" с нулевой задержкой

P.S.:
Правило в HTML5:
"после пяти вложенных таймеров интервал должен составлять не менее четырёх миллисекунд"
(Т.е. ошибки не будет, просто запуск автоматически будет замедляться на 4мс (каждый после 4ёх первых))

Этого ограничения нет в серверном JavaScript

================= 6.9 "call, apply, bind"

"call" - вызывает сразу
"bind" - возвращает новую функцию и ее мы можем вызывать в любой удобный для нас момент
"apply" - задается 2 параметра, 2ой параметр это массив из аргументов, которые попадут в эту функцию и сразу же вызовет

Синтаксис "call":
```js
func.call(context, arg1, arg2, ...)
```

Синтаксис "apply":
```js
func.apply(context, [args])
```

Эти вызовы дополняют друг друга
Для перебираемых объектов сработает "call", а где мы ожидаем псевдомассив - "apply"

================= 6.10

Как только метод передаётся отдельно от объекта - "this" теряется

Варианты решения этой проблемы:

	1:
	передать в аргумент анонимную функцию и в ней обратиться к нужному свойству через замыкание

```js
	setTimeout(() => user.sayHi(), 1000)
```

	2:
	через "bind":

```js
	let user = {
  	firstName: "Вася",
 	sayHi() {
   	alert(Привет, ${this.firstName}!)
  	}
	}

	let sayHi = user.sayHi.bind(user)

	sayHi() // Привет, Вася!

	setTimeout(sayHi, 1000) // Привет, Вася!
```

================= 6.11

У стрелочных функций нет "this"

Стрелочные функции нельзя использовать с "new"
"this" нельзя использовать с конструкторами

Стрелочные функции не имеют "arguments"

=================