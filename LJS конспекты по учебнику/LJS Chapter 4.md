================= 4.1 "Объекты"

В JavaScript 8 типов данных, из которых 7 - примитивы, а "Объекты" - более сложный тип данных, т.к. хранит в себе коллекцию различных значений
(в отличии от примитивов, примитивы в свою очередь хранят только строку, либо только число и т.д.)

Синтаксис "свойства" - *ключ: значение*

Создание объекта следующим синтаксисом:
let user = {} //литерал объекта
|| (альтернатива)
let user = new Object () //синтаксис конструктор объекта

Перечисление свойств в объекте идёт обязательно через ","

Значение может быть любого типа

Для удаления свойства используется оператор "delete"
Пример синтаксиса:
"delete user.age"
(через "." можно обращаться к свойству)

Имя свойства также может состоять из нескольких слов, но тогда оно должно записываться в кавычках
Пример синтаксиса:
("likes birds": true)

const защищает саму переменную, а не её внутренности

Для свойств, имена которых записаны в несколько слов, обращение через "." - недоступно

Но можно присвоить и обратиться к свойству объекта через квадратные скобки
Пример синтаксиса:
"let user = {}

user["likes birds"] = true
alert(user["likes birds"])

delete user["likes birds"]"

К свойству в квадратных скобках нельзя обратиться через "."

Все названия свойств (ключи) автоматически преобразуются к строке, поэтому в ключ можно записывать хоть числа
((Все "ключ" автоматически преобразуются в строки))

Оператор "in"

Оператор in использует для проверки наличия свойства в переменной
Оператор in, слева искаемое свойство, справа - переменная
Если записать слева без кавычек, то js примит это за переменную

Цикл "for...in"

Используется для перебора всех свойств объекта

================= 4.2 "Object.assign"

Когда переменная объекта копируется – копируется ссылка на него, а сам объект - не дублируется

Операторы "==" и "===" для объектов работают одинаково
Два объекта равны только в том случае, если это один и тот же объект

"Object.assign"

Object.assign используют для объеденения/клонирование объектов
Пример синтаксиса:

"let user = { name: "Иван" };

let p1 = { canView: true };
let p2 = { canEdit: true };

// копируем все свойства из p1 и p2 в user
Object.assign(user, p1, p2)
//если свойство уже имеется, то оно будет перезаписано"


================= 4.3 "Сборка мусора"

Память в JavaScript управляется "принципом достижимости"
"Достижимые значения" - это те значения, которые доступны или используются

Существуют значения, которые нельзя убрать из памяти:

	-Локальные переменные и параметры текущей функции
	-Переменные и параметры других функций в текущей цепочке вложенных вызовов
	-Глобальные переменные

Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок
JavaScript удаляет те объекты, которые стали недостижимы

Исходящие ссылки не имеют значения
Только входящие ссылки могут сделать объект достижимым

Как работает "сборщик мусора":

	1. Сборщик мусора "помечает" (запоминает) все корневые объекты
	2. Затем он идёт по их ссылкам и помечает все найденные объекты
	3. Затем он идёт по ссылкам помеченных объектов и помечает объекты, на которые есть ссылка от них
	  (Все объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды)
	4. И так далее, пока не будут посещены все ссылки (достижимые от корней)
	5. Все непомеченные объекты удаляются

================= 4.4 "this"

Функцию, которая является свойством объекта, называют методом этого объекта
Когда мы записываем функцию в свойство объекта, то мы можем пропустить слово "function" и просто записать название
Пример синтаксиса:

"let user = {
	sayHi() {
	   console.log('салам')
	}
}"

Вызов обычного "this" (console.log(this)) - вызовет ошибку, а т.е. this == undefined
У стрелочной функции нет this

	(собственный комментарий: в своё время мне помогло представление "this", как "сюда",
	 а т.е. "this.name" => "сюда.имя", и если в name: "John", то звучит вполне логично
	 "сюда.имя Джон")

================= 4.5 "new"

"Конструктор "new""

При помощи функции-конструктора "new" можно создавать множество однотипных объектов

Основной целью конструкторов - удобное повторное создание однотипных объектов

Конструктор "new" вызывается обязательно с большой буквы

Также любая функция может быть использована как конструктор

"new.target"

Используя "new.target" внутри функции, мы можем проверить, вызвана ли функция при помощи оператора "new"
Если функция вызвана при помощи "new", то в "new.target" будет сама функция, в противном случае - undefined

"Особенности return в конструкторах"

	-При вызове return с объектом, будет возвращён объект, а не this
	-При вызове return с примитивным значением, примитивное значение будет отброшено

Мы можем не ставить скобки после "new", если вызов конструктора идёт без аргументов

================= 4.6 "?."

Опциональная цепочка "?."

Проверяет на наличие значения, как и "&&", но делает это менее громозко и более понятно
Если значения нет, возвращает undefined

Если переменной или свойства, в котором мы что-то ищем - отсутствует, то выдаст ошибку

Опцианальная цепочка работате с функциями и квадратными скобками

================= 4.7 "Symbol"

"Symbol"

Создаются новые символы с помощью функции
Пример синтаксиса:
"Symbol()"

Символы всегда являются уникальными, даже если мы создадим одинаковые копии
Их описание (запись в "()") - просто метка, которая ни на что не влияет

Символы не преобразуются автоматически в строки, т.к. это абсолютно 2 разных типа
(если нам это нужно, то преобразуем явно через ".toString()"

Свойство "symbol.description" будет выводить только описание

Если нужно использовать символ при литеральном объявлении объекта, его необходимо заключить в квадратные скобки
Пример синтаксиса:
	"let id = Symbol("id")

	 "let user = {
  	  name: "Вася",
  	  [id]: 123 // просто "id: 123" не сработает
	}"

Это вызывано тем, что нам нужно вызвать "id" в качестве ключа, а не строки

Символы игнорируются циклом "for...in"

Object.assign копирует строковые и символьные свойства, в отлчии от цикла "for...in"

Глобальный реестр символов - позволяет создать в нём символы и обращаться к ним в дальнейшем
(и при каждом обращении будет возвращаться один и тот же символ)
Для чтения (или, при отсутствии, создания) символа из реестра используется вызов Symbol.for(key)

Он проверяет глобальный реестр и, при наличии в нём символа с именем key, возвращает его
Иначе же создаётся новый символ Symbol(key) и записывается в реестр под ключом key

Символы, содержащиеся в реестре, называются глобальными символами

Также существует "Symbol.keyFor(sym)", который, наоборот, принимает глобальный символ и возвращает его имя
(возвращается его описание)

"Symbol.keyFor" ищет символы в гломабальном реестере, так что он не будет работать для неглобальных символов
И если метод не найдёт символ, то вернёт "undefined"

Но то же свойство "description" - может найти локальный символ
Пример синтаксиса:

	```let globalSymbol = Symbol.for("name")
	let localSymbol = Symbol("name")

	alert( Symbol.keyFor(globalSymbol) ) // name, глобальный символ
	alert( Symbol.keyFor(localSymbol) ) // undefined для неглобального символа

	alert( localSymbol.description ) // name```

================= 4.8 "Преобразование объектов в примитивы"

Преобразование объектов в примитивы

Если мы попытаемся провести с объектами какие-либо операции
(например сложение или вычитание)
То объекты сначала автоматически преобразуются в примитивы, а затем выполняется операция

"Хинт"

Хинт - вариант преобразования объекта в примитив
Существует 3 хинта:

	"string" - преобразование к строке
	"number" - преобразование к числу
	"default" - происходит, когда оператор "не уверен", какой тип ожидать

Оператор ">" и "<" использует хинт "number"

"Вызов хинта и его преобразование"

Вызывает: "obj[Symbol.toPrimitive](hint)"

Представим, что хинт - "string", то движок делает:
"obj.toString()"
 Если ничего не находит, то пробует вызвать:
"obj.valueOf()"

В случае, если в хинте - "number", то вызывает:
"obj.valueOf()"
Если не находит, то:
"obj.toString()"

Единственное обязательное требование: методы должны возвращать примитив, а не объект

Если "toString" или "valueOf" вернёт объект, то ошибки не будет, но такое значение будет проигнорировано

Метод "Symbol.toPrimitive", обязан возвращать примитив, иначе будет ошибка

Математические операции, исключая бинарный плюс, преобразуют примитив к числу

=================

[[LJS]]